---
title: 计算机系统组成
date: 2025-09-01 17:10:52
permalink: /ruankao/softDesigner/chapterOne/computerConstitute
categories:
  - 软考
  - 软件设计师
  - 计算机基础
  - 基础
tags:
  - 软考
  - 软件设计师
  - 计算机基础
  - 基础
titleTag: 原创
description: 本专题主要记录软考软件设计师中对应计算机基础知识中的计算机系统组成，只记录自己的学习笔记，仅限当前自己的知识储备，若有错漏还望谅解，希望能够帮到备考的人，"
coverImg: /img/ruankao/computer-constitute.webp
inHomePost: false
---

# 一、计算机系统的组成

## 1.1 冯诺依曼机

冯·诺伊曼结构（von Neumann architecture），也称冯·诺伊曼模型（Von Neumann model）或普林斯顿结构（Princeton architecture），是一种将程序指令存储器和数据存储器合并在一起的计算机设计概念结构。
依据冯·诺伊曼结构设计出的计算机称做冯.诺依曼计算机，又称存储程序计算机。

### 1.1.1 冯诺依曼机特点


1. 计算机由<font style="color:red">五大部件</font>组成，分别是：运算器、控制器、存储器、输入设备和输出设备。
2. 指令和数据以<font style="color:red">同等地位</font>存于存储器中，可按照地址寻访
3. 指定和数据使用二进制的形式表示
4. 指令由操作码和地址码组成
5. <font style="color:red">以运算器为中心</font>

结构图如下所示：

::: center

![von-Neumann.webp](/img/ruankao/pages/von-Neumann.webp)

:::

### 1.1.2 存储器（主存储器）

- 主存储器主要由三大部分组成
  
  1. 存储体(Storage Body / Memory Bank)：数据的"仓库"
  2. 地址寄存器 (<font style="color:red">MAR</font>) 和地址译码驱动电路：寻址的"导航系统"
  3. 数据寄存器 (<font style="color:red">MDR</font>) 和读写电路：数据的“出入口和搬运工”

#### 1.1.2.1 存储体

存储体中重要概念：存储元(Storage Element)、存储单元(Storage Unit)、存储字(Storage Word)、存储字长(Storage Word Length)  

- 存储元 (Storage Element)：是构成存储体的<font style="color:red">最基本、最底层的物理单元</font>。例如，在DRAM芯片中，一个电容和一个晶体管共同构成一个存储元，<font style="color:red">用于存储1个bit</font>
- 存储单元 (Storage Unit)：是存储体中<font style="color:red">可被地址系统直接管理和访问的最小单位</font>。它由<font style="color:red">多个存储元组成</font>。
现代计算机中，<font style="color:red">8个存储元组成一个存储单元</font>（即1字节）。
- 存储字 (Storage Word)：是<font style="color:red">某个时刻</font>存储在一个存储单元里的<font style="color:red">数据内容</font>。它是存储单元所存储的<font style="color:red">值</font>。
- 存储字长 (Storage Word Length)：是存储体的一个<mark>设计特征</mark>，指每个<font style="color:red">存储单元能容纳的二进制位的长度</font>。

#### 1.1.2.2 数据寄存器(MDR)和地址寄存器(MAR)

它们是CPU与主存储器之间进行数据交互的<font style="color:red">**关键接口和缓冲枢纽**</font>。

| 寄存器 | 全称 | 功能                                                            | 方向 | 连接的CPU总线 |
| :--- | :--- |:--------------------------------------------------------------| :--- | :--- |
| **MAR** | Memory Address Register<br>（地址寄存器） | **存放**CPU要访问的<font style="color:red">**存储单元(主/内存)地址**</font>。 | **CPU → 主存** | **地址总线 (Address Bus)** |
| **MDR** | Memory Data Register<br>（数据寄存器） | **临时存放**要从主存**读出**或**写入**的**数据**。                             | **CPU ↔ 主存** | **数据总线 (Data Bus)** |


1. **地址寄存器 (MAR - Memory Address Register)**

   - **功能**：用于<font style="color:red">**暂时存放**</font>CPU通过**地址总线**发送过来的、想要访问的<font style="color:red">**内存地址**</font>。
   - **核心作用**：
     1.  **地址暂存与稳定**：CPU发送地址信号的时间很短，而内存的寻址操作（译码、驱动）需要一定的时间。MAR的作用就是**锁存并保持**这个地址信号，为内存内部的地址译码器提供稳定的输入，确保整个读/写操作期间地址不会改变。
     2.  **决定寻址范围**：MAR的**位数（宽度）** 直接决定了主存储器最大的可寻址空间。
         *   公式：<code>可寻址空间 = 2<sup>MAR位数</sup></code>
         *   例如：如果MAR是32位的，那么它可以存储2³²个不同的地址，对应最大4GB（2³² Bytes）的寻址空间。如果MAR是64位的，寻址空间则大得惊人（2⁶⁴ Bytes）。

   - **工作流程（以读数据为例）**
     1.  CPU想要读取地址为 `0x1234` 的数据。
     2.  CPU将地址 `0x1234` 通过 **地址总线** 送入 **MAR**。
     3.  MAR **锁存** 并 **输出** 这个地址给内存内部的 **地址译码器**。
     4.  地址译码器开始工作，根据该地址找到对应的物理存储单元。

---

2. **数据寄存器 (MDR - Memory Data Register)**

   - **功能与作用**
     *   **功能**：用于**暂时存放**CPU与主存储器之间待传输的**数据**。
     *   **核心作用**：
         1.  **数据缓冲与同步**：作为CPU数据总线和存储器内部数据线之间的**缓冲器**。CPU和内存的工作速度可能不同步，MDR在其中起到**速度匹配**和**数据暂存**的作用，防止数据丢失。
         2.  **双向数据传输**：
             *   **读操作时**：MDR存放从**存储体**中读出的数据，准备让CPU通过**数据总线**取走。
             *   **写操作时**：MDR存放CPU通过**数据总线**送来的、准备要**写入存储体**的数据。

   - **工作流程**
     *   **读操作**：
         1.  当地址译码器选中目标单元后，该单元的数据被读出。
         2.  读出的数据经过放大和整形，被送入**MDR**中暂存。
         3.  MDR将数据放到**数据总线**上，CPU再从总线上读取该数据。
     *   **写操作**：
         1.  CPU将要写入的数据通过**数据总线**送入**MDR**。
         2.  同时，CPU将目标地址通过地址总线送入MAR（找到要写入的位置）。
         3.  内存控制逻辑将MDR中的数据写入到由MAR地址选中的存储单元中。

>[!DANGER] 重要说明与现代计算机架构  
>  **位置归属**：在传统的<font style="color:red">冯·诺依曼架构</font>描述中，MAR和MDR被视为<font style="color:red">**主存储器**</font>的组成部分（即位于内存板上）。然而，在<font style="color:red">现代计算机架构中，为了追求极高的速度，**MAR和MDR通常被集成在CPU内部**</font>，成为CPU内存管理单元（MMU）或总线接口单元（BIU）的一部分。但它们的<font style="color:red">**功能完全没有改变**</font>，依然是CPU和主存之间的地址和数据接口。  
> <br/>
>  **与字长的关系**：
>  1. <font style="color:red">**MAR的位数**</font>决定了系统的**寻址能力**（是32位还是64位系统）。
>  2. **MDR**的位数通常与计算机的**字长**（Word Size）相关，但不一定相等。例如，一个64位CPU的MDR宽度可能是64位，这意味着它一次可以访问8个字节的数据（假设存储单元为8位）。但CPU仍然可以按字节、字、双字等方式来访问，底层硬件会进行转换。

### 1.1.3 运算器（Arithmetic Logic Unit, ALU）

用于执行<font style="color:red"><font style="color:red"><font style="color:red"><font style="color:red"><font style="color:red"><font style="color:red">**算术运算**</font></font></font></font></font></font>（加、减、乘、除等）和<font style="color:red">**逻辑运算**</font>（与、或、非等），是<font style="color:red">数据</font>处理的<font style="color:red">核心单元</font>。

#### 1.1.3.1 核心部件

- 核心部件总览

| 缩写      | 英文全称                               | 中文名称       | 核心功能                                                                                  |
|:--------|:-----------------------------------|:-----------|:--------------------------------------------------------------------------------------|
| **ACC** | Accumulator                        | **累加寄存器**  | 存放 <font style="color:red">**操作数**</font>或 <font style="color:red">**运算结果**</font>    |
| **MQ**  | Multiplier-Quotient Register       | **乘商寄存器**  | 在乘除运算中存放 <font style="color:red">**乘数**</font> 或 <font style="color:red">**商**</font> |
| **X**   | (General-purpose) Operand Register | **操作数寄存器** | 存放一个 <font style="color:red">**操作数**  </font>                                         |
| **ALU** | Arithmetic Logic Unit              | **算术逻辑单元** | 执行实际的 <font style="color:red">**算术和逻辑运算**</font>                                      |
| **DR**  | Data Register                      | **数据寄存器**  | 作为内存和运算器之间的 <font style="color:red">**数据缓冲**</font>                                   |
| **PSW** | Program Status Word                | **程序状态字**  | 存放运算结果的 <font style="color:red">**状态标志位** </font>                                     |

- 运算过程中的协作关系，尤其是ACC、MQ、X在乘法运算中的典型数据流：

```mermaid
flowchart LR
    subgraph CPU[运算器核心]
        direction LR
        ACC[累加寄存器 ACC]
        MQ[乘商寄存器 MQ]
        X[操作数寄存器 X]
        ALU[算术逻辑单元 ALU]
    end

    Memory[内存] <--> DR[数据寄存器 DR]
    DR <--> CPU
    ALU --> PSW[程序状态字 PSW]
    ACC <-- 运算完成后再放回ACC --> ALU
    MQ <-- 运算完成后再放回MQ --> ALU
    X --> ALU
```

---

- **各部件详细说明**

  1. <font class="blob-600" style="color:red">累加寄存器 - ACC</font>(Accumulator) 
     -   **功能**：这是运算器中<font style="color:red">**最关键**</font>的寄存器之一。它主要用于存放**被操作数**和**运算结果**。
     -   **工作方式**：
             *   在许多指令中，一个操作数默认来自ACC。
             *   ALU的运算结果也通常会<font style="color:red">**写回ACC**，覆盖旧值</font>， hence the name "累加" (Accumulate)。
     -   **示例**：执行 `ADD B` 指令，意味着 `(ACC) + (B) -> ACC`，将ACC中的值与B单元的值相加，结果存回ACC。

  2. <font class="blob-600" style="color:red">乘商寄存器 - MQ</font>(Multiplier-Quotient Register) - 
     -   **功能**：这是一个<font style="color:red">**专用寄存器**</font>，主要用于<font style="color:red">**乘法和除法**</font>操作。
     -   **工作方式**：  
         &emsp;**乘法时**：存放<font style="color:red">**乘数**</font>。运算结束后，存放结果的<font style="color:red">**低位**</font>部分（乘积可能很长，是操作数位数的两倍）。  
         &emsp;**除法时**：存放<font style="color:red">**商**</font>。除法运算后，<font style="color:red">ACC则存放**余数**</font>。
     -   **示例**：早期乘法指令 `MUL X`，可能意味着 `(ACC) × (MQ) -> ACC-MQ`，将ACC和MQ中的数相乘，<font style="color:red">结果的高位在ACC，低位在MQ</font>。

  3. <font class="blob-600" style="color:red">操作数寄存器 - X</font>(Operand Register)
     -   **功能**：这是一个<font style="color:red">通用的**操作数寄存器**</font>。
     -   **工作方式**：用于<font style="color:red">临时存放</font>另一个操作数。当需要从<font style="color:red">内存中</font>读取数据参与运算时，数据通常<font style="color:red">先送到X</font>寄存器，然后再由ALU与ACC中的数据进行运算。
     -   **示例**：执行 `SUB [1000H]` 指令，操作是：  
         &emsp;&emsp;1.  将内存地址1000H处的数据取到 **X** 寄存器。  
         &emsp;&emsp;2.  ALU执行 `(ACC) - (X)` 操作。  
         &emsp;&emsp;3.  结果送<font style="color:red">**ACC**</font>。

   4. <font class="blob-600" style="color:red">算术逻辑单元 - ALU</font>(Arithmetic Logic Unit)
      -   **功能**：这是运算器的<font style="color:red">**核心计算部件**</font>，是一个由组合逻辑电路（如加法器、移位器、逻辑门等）构成的部件，<font style="color:red">**本身不存储数据**</font>。
      -   **工作方式**：它从ACC、X、MQ等<font style="color:red">寄存器**获取操作数**</font>，根据控制单元（CU）发出的命令执行<font style="color:red">特定的算术运算</font>（加、减、乘、除）或逻辑运算（与、或、非、异或），然后将<font style="color:red">**结果输出**</font>到目标寄存器（如ACC、MQ），并<font style="color:red">设置PSW中的相应标志位</font>。

   5. <font class="blob-600" style="color:red">数据寄存器 - DR</font>(Data Register)
      -  **功能**：也称为MDR（Memory Data Register），它是<font style="color:red">**内存和运算器之间的缓冲器**</font>。
      -   **工作方式**：
          -   **读内存**：从内存读出的数据，首先被送入DR，然后再被移动到运算器所需的寄存器（如X、ACC）中。
          -   **写内存**：要写入内存的数据，也是先从运算器寄存器（如ACC）移动到DR，然后再从DR写入到指定内存地址。
      -   **目的**：协调CPU的高速和内存的相对低速，完成速度匹配。

   6. <font class="blob-600" style="color:red">程序状态字 - PSW</font>(Program Status Word)
      -   **功能**：这是一个按位定义的寄存器，每一位（或几位）代表一种<font style="color:red">**系统状态标志**</font>，主要由ALU运算结果设置。
      -   **核心标志位**：
          *   **CF (Carry Flag)**：**进位标志**。无符号数运算产生进位或借位时置1。
          *   **OF (Overflow Flag)**：**溢出标志**。有符号数运算结果超出表示范围时置1。
          *   **ZF (Zero Flag)**：**零标志**。运算结果为0时置1。
          *   **SF (Sign Flag)**：**符号标志**。运算结果为负时置1（即最高位为1）。
          *   **PF (Parity Flag)**：**奇偶标志**。结果中1的个数为偶数时置1。

---

- **协同工作示例：乘法运算** 计算 `5 * 3`。

  1.  **初始化**：
      *   将被乘数 `5` 放入 **ACC**。
      *   将乘数 `3` 放入 **MQ**。
      *   控制器发出乘法操作命令。

  2.  **执行运算**：
      *   **ALU** 从ACC和MQ中取出操作数，执行乘法操作。
      *   乘积 `15` 是一个比原操作数更长的数。
      *   结果的高位部分（本例中为`0`）放回 **ACC**。
      *   结果的低位部分（`15`）放入 **MQ**。
      *   **PSW** 中的标志位根据结果 `15` 被更新（例如ZF=0，SF=0，因为15非零且为正）。

  3.  **结果**：
      -   **ACC-MQ** 寄存器对共同构成了乘积结果。

### 1.1.4 控制器（Arithmetic Logic Unit, ALU）

控制器是计算机的“指挥中心”，它的作用是确保<font class="blob-600" style="color:red">指令</font>能够被<font class="blob-600" style="color:red">有序地取出、解析和执行</font>。

控制器各核心部件在“取指-执行”周期中的工作流程与协作关系：

```mermaid
flowchart LR
A["取指周期 (Fetch Cycle)"]
B["执行周期 (Execute Cycle)"]

A --> S1[PC将下一条指令地址 -> AR]
S1 --> S2[AR指向内存地址<br>指令被读出 -> DR]
S2 --> S3[DR中的指令 -> IR]
S3 --> S4["PC + 1 -> PC<br>指向下一条指令"]
S4 --> D{指令译码}

D --> B

B --> T1[ID分析IR中的指令]
T1 --> T2[CU根据译码结果<br>发出微操作控制信号序列]
T2 --> T3[执行指令<br>如: AR指向操作数地址<br>数据经DR读写<br>ALU进行运算等]
T3 --> A
```

部件的详细说明：

---

#### 1.1.4.1 核心部件总览

| 缩写     | 英文全称                 | 中文名称      | 核心功能                                                                             |
|:-------|:---------------------|:----------|:---------------------------------------------------------------------------------|
| **CU** | Control Unit         | **控制单元**  | 控制器的核心，<font style="color:red">**发出控制信号**</font> 的部件                             |
| **IR** | Instruction Register | **指令寄存器** | 存放<font style="color:red">**当前正在执行**</font>的指令                                   |
| **PC** | Program Counter      | **程序计数器** | 存放<font style="color:red">下一条</font>要执行的指令的<font style="color:red">**地址**</font> |
| **AR** | Address Register     | **地址寄存器** | 存放当前要访问的**内存地址**                                                                 |
| **ID** | Instruction Decoder  | **指令译码器** | <font style="color:red">**解析**</font>IR中的指令，确定操作类型                               |

---

#### 1.1.4.2 各部件详细说明

1. <font class="blob-600 color-red">控制单元 - CU</font>(Control Unit)
  - **功能**：这是控制器乃至整个CPU的<font class="color-red">**真正核心**</font>和“神经中枢”。它本身<font class="blob-600 color-red">不存储数据</font>，而是<font class="color-red">**产生控制计算机其他所有部件协同工作的微操作命令信号**</font>。
  - **工作方式**：
      1.  它根据 <font style="color:red">**指令译码器（ID）**</font> 的输出（这是一条什么指令？）。
      2.  根据 <font style="color:red">**时序信号**</font> （时钟脉冲）。
      3.  根据 <font style="color:red">**状态信息**</font> （来自PSW的标志位，如进位、零标志等）。
      4.  产生一个特定的、具有固定时间顺序的<font style="color:red">**微操作控制信号序列**</font>。
    - **示例**：执行一条 `ADD` 加法指令时，CU会按顺序产生以下控制信号：从<font style="color:red">内存</font>取操作数 -> 将<font style="color:red">操作数送入ALU</font> -> 命令ALU做加法 -> 将<font style="color:red">结果送回寄存器</font> -> 更新状态寄存器等。<font style="color:red">每一步都精确到时钟周期</font>。

2. <font class="blob-600 color-red">指令寄存器 - IR</font>(Instruction Register)
   - **功能**：用于存放 <font style="color:red">**当前正在被执行**</font> 的指令。
   - **工作方式**：
       1.  从内存中取出的指令，首先被送到 <font style="color:red">**数据寄存器（DR）**</font>
       2.  然后，该指令从<font style="color:red">DR</font>被送入<font style="color:red">**IR**</font>中
       3.  指令在IR中被分为两部分：
           - **操作码（Opcode）**：送交<font style="color:red">**ID**</font>进行<font style="color:red">译码</font>。
           - **地址码（Address）**：可能包含操作数的地址，可送交<font style="color:red">**AR**用于寻址</font>。
   - **特点**：指令在<font style="color:red">执行期间会一直被保存在IR中</font>，确保CU执行的步骤是针对同一条指令。

3. <font class="blob-600 color-red">程序计数器 - PC</font>(Program Counter) 
   - **功能**：也叫<font style="color:red">**指令指针寄存器（IP）**</font>。它的内容是**下一条要执行的指令在内存中的地址**。
   - **工作方式**：
       1.  **顺序执行**：当一条指令被<font style="color:red">取出</font>后，<font style="color:red">PC会自动**加1**</font>（或加上指令长度的字节数），指向<font style="color:red">下一条</font>指令的地址。
       2.  **跳转/分支**：当执行<font style="color:red">跳转</font>指令（如 `JMP`）、调用子程序（`CALL`）或发生中断时，PC会被装入<font style="color:red">新的</font>目标地址，从而改变程序的执行流程。
   - **重要性**：PC保证了程序能够 <font style="color:red">**自动地、连续地**</font> 执行下去，是实现“存储程序”概念的关键。

4. <font class="blob-600 color-red">地址寄存器 - AR</font>(Address Register)
   - **功能**：用于存放<font style="color:red">当前CPU要访问的**内存单元地址**</font>。
   - **工作方式**：
     1.  无论是取指令还是存取数据，都需要<font style="color:red">先给出地址</font>。
     2.  这个地址可以来自PC（取指令时）、来自IR的地址码部分（取操作数时）或是运算结果。
     3.  该地址被放入<font style="color:red">**AR**</font>，AR通过 <font style="color:red">**地址总线**</font> 将地址信号送到内存，内存根据该地址进行寻址。
   - **作用**：作为CPU地址总线的<font style="color:red">**驱动器**</font>和<font style="color:red">**暂存器**</font>，确保地址信号的稳定。

5. <font class="blob-600 color-red">指令译码器 - ID</font>(Instruction Decoder)
   - **功能**：一个<font style="color:red">**组合逻辑电路**</font>，负责对IR中的<font style="color:red">**操作码（Opcode）** 进行解析（译码）</font>。
   - **工作方式**：
       1.  它将二进制编码的操作码（如 `10110110`）作为输入。
       2.  通过内部逻辑电路，将其“翻译”成对应指令所需的<font style="color:red">**控制信号有效位**</font>。
       3.  译码结果输出给<font style="color:red">**CU**</font>，告诉CU“现在要执行的是什么操作”（是加法？是比较？还是跳转？）。
   - **类比**：像一个**翻译官**，将二进制指令“翻译”成CU能理解的“命令意图”。CU再根据这个“意图”去组织具体的微操作步骤。

---

#### 1.1.4.3 协同工作流程示例：执行一条指令

以执行一条简单指令 `ADD [1000H]` (将地址1000H中的数加到ACC中) 为例：

1.  **取指（Fetch）**：
    - <font style="color:red">PC</font>将指令地址送给<font style="color:red">AR</font>。
    - <font style="color:red">AR</font>将地址送内存，内存取出指令，经<font style="color:red">DR</font>送到<font style="color:red">IR</font>。
    - <font style="color:red">PC</font>自动加1，指向下一条指令。
    - <font style="color:red">ID</font>开始译码IR中的操作码，发现是 `ADD` 指令，并通知<font style="color:red">CU</font>。

2.  **执行（Execute）**：
    - <font style="color:red">CU</font>根据ID的译码结果，开始发出微操作信号。
    - <font style="color:red">IR</font>中的地址码部分（`1000H`）被送入<font style="color:red">AR</font>。
    - <font style="color:red">AR</font>将地址 `1000H` 送内存，内存找到该地址的数据，经<font style="color:red">DR</font>读出。
    - <font style="color:red">CU</font>控制将<font style="color:red">DR</font>中的数据送入ALU的一个输入端，ACC中的数据送入另一个输入端。
    - <font style="color:red">CU</font>命令ALU执行加法操作。
    - <font style="color:red">CU</font>控制将ALU的结果写回<font style="color:red">ACC</font>，并更新<font style="color:red">PSW</font>状态位。

#### 1.1.4.4 总结

这些部件精密协作，周而复始地<font style="color:red">完成**取指 -> 译码 -> 执行**的循环</font>，从而让计算机自动运行程序：
1. **PC** 和 **AR** 负责<font style="color:red">**寻址**</font>。
2. **IR** 和 **ID** 负责<font style="color:red">**指令持有和解析**</font>。
3. **CU** 是总指挥，负责根据前者的信息<font style="color:red">**发号施令**</font>。


### 1.1.5 冯诺依曼机小结

```markmap

# 五大部件

## 运算器(Arithmetic Logic Unit) → ALU
 ### 功能
 - 执行算术运算（加、减、乘、除等）和逻辑运算（与、或、非等），是数据处理的核心单元。
 
 ### 作用
 - 算术运算：如加、减、乘、除等基本数学运算。
 - 逻辑运算：如与、或、非、异或等比较和判断操作。
 - 核心地位：它是计算机真正进行“计算”的地方。所有程序中的计算和逻辑判断任务，最终都会分解为一个个简单的算术或逻辑操作，由运算器来完成。

## 控制器(Control Unit) → CU
 ### 功能
  - 它是整个计算机的指挥中心和神经中枢，负责协调和控制其他所有部件的工作。
 ### 作用
  - 取指令:从存储器中读取程序的下一条指令。
  - 译码：分析指令，弄清楚这条指令要求完成什么操作。
  - 执行：根据指令的含义，向相关的部件（如运算器、存储器、输入/输出设备）发出控制信号，命令它们执行相应的操作。
  - 周而复始：控制器通过重复“取指-译码-执行”这个过程，让计算机能够自动、连续地运行程序。

## 存储器(Memory)
 ### 功能
  - 用于存储程序和数据。
 ### 作用
  - 内存 (主存储器，如RAM)：直接与CPU交换数据，速度快但容量较小，断电后数据丢失。我们运行的程序和正在处理的数据都必须先加载到内存中，CPU才能进行处理。
  - 外存 (辅助存储器，如硬盘、SSD、U盘)：用于长期、大量地存储数据，速度较慢但容量大，断电后数据不丢失。操作系统、应用程序、文档、照片等都存储在这里。

## 输入设备(Input Devices)
 ### 功能
  - 用于向计算机输入（接收）外部信息和数据。
 ### 作用
  - 将信息转换成机器能够识别的形式（二进制），并送入存储器中

## 输出设备(Output Devices)
 ### 功能
  - 用于将计算机处理后的结果输出，呈现给用户。
 ### 作用
 - 将计算机内部的二进制数据转换成人或其他设备可以识别和接收的形式（图像、文字、音频、视频等）
```

> [!DANGER] 注意
>
> - 在现代计算机中通常将 `运算器` 和 `控制器` 集成在一块芯片上，称之为中央处理器，即 `CPU`
> - 这五大部件通过系统总线（Bus） 相互连接，进行数据和指令的传输，共同构成了一个能够自动、高速处理信息的完整系统。

## 1.2 Flynn 分类法

Flynn 分类法由 Michael J. Flynn 在 1966 年提出，是一种根据<font class="blob-600 color-red">指令流（Instruction Stream）</font> 和<font class="blob-600 color-red">数据流（Data Stream）</font> 的数量对计算机体系结构进行分类的经典方法。

- 指令流 (Instruction Stream)：计算机执行的指令序列
- 数据流 (Data Stream)：指令流所操作的数据序列

它通过识别计算机中<font class="blob-600 color-red">同时存在</font>多少条指令流和多少个数据流，将计算机划分为<font class="blob-600 color-red">四大类型</font>

### 1.2.1 四大类型计算机特点

---

1. <font class="blob-600 color-red">SISD</font> (Single Instruction, Single Data)
   - <font class='blob-600 color-red'>单指令流，单数据流</font>
   - 描述：这是最传统的<font class="blob-600 color-red">串行计算机</font>架构。在任何时钟周期内，只有<font class="blob-600 color-red">一个控制单元</font>（CU）从内存中取出<font class="blob-600 color-red">一条指令</font>，并只对<font class="blob-600 color-red">一个数据流</font>进行操作
   - 关键特点：
     - <font class='blob-600 color-red'>纯粹的顺序执行</font>
     - 典型代表：早期的<font class="blob-600 color-red">单核处理器</font>
     - 符合经典的<font class="blob-600 color-red">冯·诺依曼体系结构</font>
2. <font class="blob-600 color-red">SIMD</font> (Single Instruction, Multiple Data)
    - <font class='blob-600 color-red'>单指令流，多数据流</font>
    - 描述：一条指令可以同时<font class="blob-600 color-red">对多个不同的数据流执行相同的操作</font>。<font class="blob-600 color-red">一个控制单元</font>（CU）控制<font class="blob-600 color-red">多个处理单元（PU）</font>，所有PU在同一时刻执行同一条指令，但操作的是<font class="blob-600 color-red">不同的数据</font>
    - 关键特点：
        - 非常适合数据<font class="blob-600 color-red">并行计算</font>，即对<font class="blob-600 color-red">大量数据</font>执行<font class="blob-600 color-red">相同</font>的操作
        - 典型代表：
          - <font class="blob-600 color-red">向量处理器</font>：Cray超级计算机
          - 现代处理器中的<font class="blob-600 color-red">扩展指令集</font>：Intel 的 MMX, SSE, AVX 和 ARM 的 NEON。这些指令允许一条指令同时对多个数据（如4个float数）进行加法等操作
          - <font class="blob-600 color-red">GPU</font> (图形处理器)：GPU的核心渲染理念就是SIMD，对大量像素或顶点执行相同的着色指令
3. <font class="blob-600 color-red">MISD</font> (Multiple Instruction, Single Data)
    - <font class='blob-600 color-red'>多指令流，单数据流</font>
    - 描述：<font class="blob-600 color-red">多个处理单元（PU）同时对同一份数据流</font>执行<font class="blob-600 color-red">不同</font>的指令。这种架构非常罕见，几乎没有商业化的成功实践
    - 关键特点：
        - <font class="blob-600 color-red">理论上</font>可用于容错计算（多个PU对同一数据进行计算并投票表决结果）或异构计算（对同一数据流进行一系列不同的操作）
        - 常被引用的唯一例子是冗余容错系统，多个独立计算的单元对相同输入进行计算以检查错误
4. <font class="blob-600 color-red">MIMD</font> (Multiple Instruction, Multiple Data)
    - <font class='blob-600 color-red'>多指令流，多数据流</font>
    - 描述：这是目前<font class="blob-600 color-red">最主流</font>、最通用的并行计算机架构。系统中有<font class="blob-600 color-red">多个</font>处理单元（PU），每个都有<font class="blob-600 color-red">自己的控制单元（CU</font>）。因此，每个PU可以<font class="blob-600 color-red">独立地执行不同的指令</font>，操作<font class="blob-600 color-red">不同</font>的数据
    - 关键特点：
        - 实现了<font class="blob-600 color-red">任务并行</font>和<font class="blob-600 color-red">数据并行</font>
        - 处理器之间<font class="blob-600 color-red">需要通信和同步机制</font>
        - 典型代表：
          - <font class="blob-600 color-red">多核处理器</font>：你的双核、四核、八核CPU。每个核心都是一个独立的SISD处理单元，它们共同组成了一个MIMD系统
          - <font class="blob-600 color-red">多处理器系统</font>：服务器上的多个CPU
          - <font class="blob-600 color-red">计算机集群</font>：通过网络连接的多台计算机

### 1.2.2  总结与对比

---

| 类型       | 指令流 | 数据流 | 特点                                                | 常见应用                                                     |
|:---------|:----|:----|:--------------------------------------------------|:---------------------------------------------------------|
| **SISD** | 单   | 单   | 串行执行                                              | 传统单核处理器                                                  |
| **SIMD** | 单   | 多   | <font class="blob-600 color-red">数据级并行</font>     | 向量计算、多媒体指令集 (SSE/AVX)、GPU                                |
| **MISD** | 多   | 单   | <font class="blob-600 color-red">理论模型</font>，极少应用 | 容错系统（学术研究）,<font class="blob-600 color-red">实际不存在</font> |
| **MIMD** | 多   | 多   | <font class="blob-600 color-red">任务级并行</font>     | **多核处理器**、分布式系统、计算机集群                                    |
