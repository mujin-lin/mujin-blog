---
title: 指令系统
date: 2025-09-02 10:56:39
permalink: /ruankao/softDesigner/chapterOne/instructionSystem
categories:
  - 软考
  - 软件设计师
  - 计算机基础
  - 基础
tags:
  - 软考
  - 软件设计师
  - 计算机基础
  - 基础
titleTag: 原创
top: false
sticky: 0
sidebar: true
article: true
comment: true
description: null
coverImg: /img/ruankao/instruction.webp
docAnalysis: true
inCatalogue: true
autoTitle: true
articleUpdate: true
inHomePost: false
---

## 一、 指令系统（Instruction Set Architecture, ISA）

指令系统（Instruction Set Architecture, ISA），通常也被称为指令集、计算机架构
是一套详细的**规范**和**标准**，定义了计算机硬件能够识别和执行的**基本操作指令的集合**

### 1.1 指令格式

指令格式是指令的<font style="color:red">二进制</font>编码方式，一条指令通常包含<font style="color:red">操作码</font>和<font style="color:red">操作数/地址码</font>

- 操作码：指明操作的类型，如算术运算（加、减、乘、除）、逻辑运算（与、或、非）、数据传送（加载、存储）、控制流（跳转、调用、返回）等
- 操作数/地址码：提供操作的<font style="color:red">数据来源</font>、提供结果的<font style="color:red">存放目的地</font>、提供程序执行的目标位置

### 1.2 指令操作数的寻址方式

1. <font class="blob-600 color-red">立即（数）寻址</font> (Immediate Addressing)

    - **核心思想**：操作数<font style="color:red">**直接包含在指令本身中**</font>。指令的操作数字段不是地址，就是数据本身。
    - **工作原理**：CPU从指令流中取出指令后，操作数部分<font style="color:red">立刻可用</font>，无需再次访问内存或寄存器。
    - **优点**：<font style="color:red">**速度最快**</font>，因为取指后立即得到操作数。
    - **缺点**：数值的大小和范围<font style="color:red">受操作数字段长度的限制</font>，不灵活。

2. <font class="blob-600 color-red">直接寻址</font> (Direct Addressing)
    - **核心思想**：指令的操作数字段直接给出的是操作数在<font style="color:red">**内存中的地址**</font>。
    - **工作原理**：CPU根据指令中给出的地址，<font style="color:red">**直接访问一次内存**</font>即可从该地址读取或写入操作数。
    - **优点**：<font style="color:red">简单直观</font>。
    - **缺点**：地址空间<font style="color:red">受限于操作数字段的宽度</font>（例如16位操作数只能直接寻址64KB空间）。如果地址是固定的，程序移植性差。

3. <font class="blob-600 color-red">寄存器寻址</font> (Register Addressing)

    - **核心思想**：操作数存放在<font style="color:red">**CPU内部的寄存器**</font>中。
    - **工作原理**：指令中指定寄存器编号，CPU<font style="color:red">直接访问该寄存器</font>获取操作数。
    - **优点**：<font style="color:red">**速度极快**</font>（比访问内存快多个数量级），<font style="color:red">指令长度短</font>（因为寄存器数量少，编号只需很少几位）。
    - **缺点**：可用的寄存器数量<font style="color:red">有限</font>。

4. <font class="blob-600 color-red"><font class="blob-600 color-red">寄存器间接寻址</font></font> (Register Indirect Addressing)

    - **核心思想**：指令中指定的<font style="color:red">寄存器</font>里存放的<font style="color:red">不是数据本身</font>，而是数据在<font style="color:red">内存中的地址</font>。
    - **工作原理**：CPU<font style="color:red">先访问寄存器</font>，拿到有效地址(EA)，然后根据这个地址<font style="color:red">再访问内存</font>，才能取得最终的操作数。
    - **优点**：非常<font style="color:red">灵活</font>，通过改变<font style="color:red">寄存器的值</font>就可以访问<font style="color:red">内存中不同的位置</font>，常用于处理数组、字符串、指针等。
    - **缺点**：需要<font style="color:red">**两次访问**</font>（一次读寄存器，一次读内存），比直接寄存器寻址慢。

5. <font class="blob-600" style="color:red">寄存器相对寻址</font> (Register Relative Addressing) 或 <font class="blob-600" style="color:red">基址寻址</font>

    - **核心思想**：操作数的有效地址由一个<font style="color:red">基址寄存器</font>的内容加上一个<font style="color:red">偏移量（Displacement）</font> 形成。`EA = (Base Register) + Offset`
    - **工作原理**：偏移量直接<font style="color:red">包含在指令中</font>，是一个常数。CPU<font style="color:red">先取出寄存器的值</font>和<font style="color:red">指令中的偏移量，相加得到有效地址</font>，再去访问内存。
    - **优点**：非常适合访问<font style="color:red">结构体字段</font>和<font style="color:red">数组元素</font>。基址寄存器可以指向结构/数组的起始地址，偏移量用来访问特定字段/元素。

6. <font class="blob-600 color-red">变址寻址</font> (Indexed Addressing)

    - **核心思想**：与<font style="color:red">寄存器相对寻址非常相似</font>，通常使用一个<font style="color:red">变址寄存器</font>（如SI, DI）的内容加上一个<font style="color:red">基地址</font>（可能在指令中，也可能在另一个寄存器中）来形成有效地址。`EA = Base + (Index Register)`
    - **工作原理**：变址寄存器的值通常作为数组的索引（0, 1, 2...），通过改变它的值来遍历数组。
    - **优点**：是<font style="color:red">循环遍历数组的理想选择</font>。只需在循环中改变变址寄存器的值即可。

>[!WARNING] 注意
>  现代处理器中，<font style="color:red">**寄存器相对寻址**</font>和<font style="color:red">**变址寻址**</font>的界限已经很模糊，常被统称为<font style="color:red">**基址加变址寻址**</font>。

7. <font class="blob-600 color-red">基址加变址寻址</font> (Based Indexed Addressing)

    - **核心思想**：有效地址由一个<font style="color:red">基址寄存器</font>的内容加上一个<font style="color:red">变址寄存器</font>的内容共同形成。`EA = (Base Register) + (Index Register)`
    - **工作原理**：基址寄存器指向一个基地址（如数组起始），变址寄存器提供索引偏移。
    - **优点**：极其灵活，非常适合访问<font style="color:red">二维数组</font>或<font style="color:red">结构体数组</font>。基址寄存器可以指向不同的行（或不同的结构体），变址寄存器指向行内的列（或结构体内的字段）。
    - **缺点**：需要<font style="color:red">计算两个寄存器的和，速度相对较慢</font>。

8. **小结**

| 寻址方式        | 有效地址 (EA) 计算           | 优点                                         | 缺点                                          | 常见用途             |
|:------------|:-----------------------|:-------------------------------------------|:--------------------------------------------|:-----------------|
| **立即寻址**    | 操作数 = 指令中的立即数          | <font style="color:red">最快</font>          | <font style="color:red">数值范围受限</font>       | **初始化、常量操作**     |
| **直接寻址**    | EA = 指令中的地址码           | <font style="color:red">简单 </font>         | <font style="color:red">地址空间受限</font>       | **访问全局静态变量**     |
| **寄存器寻址**   | 操作数在指令指定的寄存器中          | <font style="color:red">极快</font>          | <font style="color:red">数量有限</font>         | **局部变量、中间结果**    |
| **寄存器间接寻址** | EA = (寄存器)             | <font style="color:red">灵活</font>，可指向任何位置  | 需<font style="color:red">两次内存</font>访问(取指后) | **指针、动态数据**      |
| **寄存器相对寻址** | EA = (基址寄存器) + 偏移量     | 适合<font style="color:red">结构体、数组 </font>   | -                                           | **访问数组元素、结构体字段** |
| **变址寻址**    | EA = 基地址 + (变址寄存器)     | 适合<font style="color:red">遍历数组</font>      | -                                           | **循环操作数组**       |
| **基址加变址寻址** | EA = (基址寄存器) + (变址寄存器) | <font style="color:red">极其灵活</font>，适合二维结构 | <font style="color:red">计算稍慢</font>         | **二维数组、结构体数组**   |

### 1.3 指令系统分类

指令系统分为：复杂指令集（CISC：Complex Instruction Set Computer）和精简指令集（RISC：Reduced Instruction Set Computer）对比如下表所示

| 特性维度      | 📚 CISC (复杂指令集)                                          | ✨ RISC (精简指令集)                                           |
|:----------|:---------------------------------------------------------|:---------------------------------------------------------|
| **设计哲学**  | 复杂、庞大<font style="color:red">硬件实现功能</font>               | <font style="color:red">简单、精简</font>、指令简单高效，编译器组合功能      |
| **指令数量**  | <font style="color:red">多</font> (数百条)，包含大量专用指令          | <font style="color:red">少</font> (通常<100条)，仅保留最常用指令      |
| **指令长度**  | <font style="color:red">可变长</font> (1-15字节不等)，灵活但译码复杂    | <font style="color:red">固定长</font> (通常32位)，译码简单，利于流水线    |
| **内存访问**  | <font style="color:red">多数指令</font>可直接操作内存数据             | <font style="color:red">只有LOAD/STORE</font>指令可访问内存       |
| **执行周期**  | <font style="color:red">变化大</font> (1到上百周期)，难以预测         | <font style="color:red">大多单周期</font>完成，规律性强              |
| **指令使用率** | <font style="color:red">极不均衡</font> (80%时间只用20%指令)       | <font style="color:red">相对均衡</font>，每条指令都常用              |
| **寄存器数量** | <font style="color:red">较少</font> (如x86: 8-16个)，导致更多内存访问 | <font style="color:red">较多</font> (通常32个)，减少内存访问         |
| **控制方式**  | <font style="color:red">微码(Microcode</font> 控制，灵活但有转换开销  | <font style="color:red">硬布线(Hardwired)、组合逻辑</font>控制，速度快 |
| **流水线支持** | <font style="color:red">差</font>：变长指令、周期不一导致流水线易阻塞       | <font style="color:red">极佳</font>：固定长度、单周期完美支持流水线        |

### 1.4 指令的执行方式

指令的执行方式有顺序、重叠、和流水方式三种

#### 1.4.1 顺序执行

这是最简单、最原始的执行方式。

- **工作过程：**
  1. 取出第k条指令。
  2. 执行第k条指令。
  3. 只有第k条指令<font style="color:red">完全执行完毕</font>后，才能开始取出第k+1条指令。
- **优点：**
  - <font style="color:red">控制逻辑极其简单</font>，硬件实现容易。
- **缺点：**
  - <font style="color:red">速度慢，效率极低</font>。CPU的各功能部件（如取指部件、执行部件）在大部分时间内是串行工作的，利用率很低。例如，在执行指令时，取指部件是空闲的。

#### 1.4.2 重叠执行

为了提升效率，让不同部件同时工作，这就产生了重叠执行方式。
**"取指k+1"** 和 **"执行k"** 这两个分别由不同部件完成的操作，可以同时进行。

- **工作过程：**
    1. 在<font style="color:red">执行第k条指令的同时，预取第k+1条</font>指令。
- **优点：**
    - 相比于顺序方式，<font style="color:red">效率显著提高</font>。它缩短了指令的平均执行时间，使CPU功能部件的利用率提升。
- **缺点：**
    - 需要解决<font style="color:red">访存冲突</font>：如果"执行k"和"取指k+1"都需要访问内存，就会发生冲突（因为一个内存通常只有一个端口）

### 1.4.3 流水执行方式（指令流水线）

流水方式是重叠方式的并行思想的进一步发展和升华。它将指令的整个执行过程<font style="color:red">精细地分解为多个耗时基本相等的子过程（称为"段"或"级"）</font>，每个<font style="color:red">子过程由一个专用</font>的功能部件完成。

- **工作过程（以经典5段流水线为例）**：
  1.  **取指（IF）**：从指令缓存取指令。
  2.  **译码/读寄存器（ID）**：译码并从寄存器堆读取操作数。
  3.  **执行（EX）**：在ALU中进行计算或地址计算。
  4.  **访存（MEM）**：访问数据缓存（如果是Load/Store指令）。
  5.  **写回（WB）**：将结果写回寄存器。
  - 每个阶段完成后，指令及其结果被传递到下一阶段，就像在流水线上一样。

- **优点**：
  - <font style="color:red">极高的并行度</font>，大幅提高了指令的吞吐率（Throughput）。<font style="color:red">理想情况下，每个时钟周期可以完成一条指令（CPI ≈ 1）</font>。
- **缺点 & 挑战**：
  - <font style="color:red">需要解决多种"冒险（Hazard）"</font>，这些冒险会破坏流水线的流畅性，导致性能下降：
    -  <font style="color:red">资源冒险（Structural Hazard）</font>：两条指令争抢同一个硬件资源（如同时访存）。
    - <font style="color:red">数据冒险（Data Hazard）</font>：后一条指令需要前一条指令的计算结果，但结果还未产生（<font style="color:red">读后写（RAW）</font> 是主要问题）。
    -   <font style="color:red">控制冒险（Control Hazard）</font>：遇到分支指令时，无法确定下一条指令的地址，导致流水线停顿。
  - 解决冒险需要增加<font style="color:red">转发（Forwarding/Bypassing）、流水线互锁（Interlock）、分支预测（Branch Prediction）</font>等复杂硬件机制。

- **时空图**：

  ![instruction-flow-line.webp](/img/ruankao/pages/instruction-flow-line.webp)

- 从第5个时钟周期开始，每个周期都有一条指令完成（WB）。

### 1.4.4 小结

| 特性   | 顺序方式 | 重叠方式                                | 流水方式                                     |
|:-----|:-----|:------------------------------------|:-----------------------------------------|
| 本质   | 串行执行 | <font style="color:red">一次重叠</font> | <font style="color:red">多次重叠</font>      |
| 并行度  | 无    | <font style="color:red">低</font>    | <font style="color:red">高</font>         |
| 控制逻辑 | 简单   | <font style="color:red">中等</font>   | <font style="color:red">复杂（需处理冒险）</font> |
| 效率   | 最低   | <font style="color:red">较高</font>   | <font style="color:red">最高（理想情况下）</font> |

### 1.5 <font style="color:red">指令流水线的计算</font>

设流水线执行周期为 <font style="color:red">$Δp$</font> ，流水线每个部分执行完成的时间为 <font style="color:red">$t$</font> ，1条指令执行所需时间的 <font style="color:red">$t_i$</font> ，
指令条数为 <font style="color:red">$n$</font> ，执行 $n$ 条指令所花的时间为 <font style="color:red">$T$</font>  


#### 1.5.1 常用公式

- 流水线周期计算公式为

:::center  
$流水线周期(ΔP)=max(t_1,t_2,t_3 ...... t_n)$  
::: 

- 1条指令执行的时间

:::center  
$1条指令执行时间(t_i)=sum(t_1,t_2,t_3 ...... t_n)$  
:::

- 流水线执行时间

:::center  
$T=1条指令执行时间(t_i)+(指令条数(n)-1) × 流水线周期(ΔP)$  
::: 

- 流水线的吞吐率( $TP$ )：在<font style="color:red">单位时间</font>内流水线所<font style="color:red">完成</font>的任务教量或输出结果数量

:::center  
$TP=\frac{指令条数(n)}{流水线执行时间(T)}$  
::: 

- 流水线的加速比( $S$ )：完成同样一批任务,不使用流水线的执行的时间与使用流水线的执行时间之比

:::center  
$S=\frac{不使用流水线执行时间}{使用流水线执行时间}$  
::: 

#### 1.5.2 计算示例

若指令流水线，把一条指全分为取指,分析，执行三部分,三部分的执行时间2ns， 2ns，1ns。  
- 问：流水线周期是多少？100条指今全部执行完毕需要多久？求流水线的吞吐率是多少？流水线的加速比是多少？  
- 答：  
  1. 流水线周期：$max(2,2,1)=2ns$
  2. 100条指今全部执行完毕时间：$2+2+1+(100-1) × 2ns = 203ns$
  3. 流水线吞吐率：$TP=\frac{100}{2+2+1+(100-1) × 2ns}=0.49$
  4. 流水线的加速比：$S=\frac{(2+2+1)×100}{2+2+1+(100-1) × 2ns}=2.46$


