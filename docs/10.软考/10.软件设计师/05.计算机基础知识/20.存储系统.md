---
title: 存储系统
date: 2025-09-02 20:12:20
permalink: /ruankao/softDesigner/chapterOne/storageSystem
categories:
  - 软考
  - 软件设计师
  - 计算机基础
  - 基础
tags:
  - 软考
  - 软件设计师
  - 计算机基础
  - 基础
titleTag: 原创
top: false
sticky: 0
sidebar: true
article: true
comment: true
description: null
coverImg: /img/ruankao/storage-system.webp
docAnalysis: true
inCatalogue: true
autoTitle: true
articleUpdate: true
inHomePost: false
---

# 一、 存储系统

- 存储系统是计算机系统的核心组成部分，其设计直接决定了计算机的性能、成本和可靠性。

## 1.1 存储系统层次结构

- 层次结构金字塔

![storage-system.webp](/img/ruankao/pages/storage-pyramid.webp)

- 主存 → 辅存：实现了虚拟存储系统，<font style="color:red">解决了主存容量不够的问题</font>
- Cache → 主存：解决了<font style="color:red">主存与CPU速度不匹配的问题</font> 
- 调用关系图

```mermaid
flowchart LR
    A[CPU] <-->|直接访问<br>速度匹配| B[Cache<br>高速缓存]
    B <-->|缓解速度矛盾<br>'自动缓存'<br>由硬件自动完成| C[主存<br>Main Memory]
    C <-->|缓解容量矛盾<br>“虚拟内存”<br>由硬件+操作系统完成| D[辅存<br>Secondary Storage]
   

    subgraph A [CPU]
        A1[运算器]
        A2[控制器]
        A3[寄存器]
    end

    subgraph B [高速存储层]
        B1[L1 Cache]
        B2[L2 Cache]
        B3[L3 Cache]
    end

    subgraph C [主存层]
        C1[DRAM]
    end

    subgraph D [辅存层]
        D1[SSD]
        D2[HDD]
    end
```
- **特点**
  1. **自上而下（从CPU向外）**：
      - <font style="color:red">速度越来越慢</font>
      - <font style="color:red">容量越来越大</font>
      - <font style="color:red">每位成本越来越低</font>
      - <font style="color:red">访问频率越来越低</font>

  2. **层次结构**：
      - **高速存储**：寄存器、缓存（L1/L2/L3）- <font style="color:red">Cache</font>
          - 离CPU最近，<font style="color:red">速度最快</font>
          - 使用SRAM技术
      - **主存**：主存储器（RAM）
          - 使用DRAM技术
          - <font style="color:red">易失性</font>存储器
      - **辅存**：SSD、HDD、磁带等
          - <font style="color:red">非易失性</font>存储器
          - <font style="color:red">用于长期存储</font>

  3. **工作方式**：
      - 数据按照"局部性原理"在层次间移动
      - CPU首先在<font style="color:red">最高层（寄存器）</font>寻找数据
      - 如果找不到（未命中），则<font style="color:red">依次</font>向下一层查找
      - 数据从下层调入上层时，通常<font style="color:red">会预取周围的数据</font>

## 1.2 存储系统分类

1. 按位置分：可分为<font color="red">内存</font>和<font style="color:red">外存</font>
   - 内存（主存）：位于主机板内，CPU可直接或通过总线直接访问，用来存储<font color="red">当前运行</font>所需要的程序和数据，<font color="red">速度快、容量小</font>，例：**内存条(Cache, DRAM), CPU内置缓存**。
   - 外存（辅存）：位于主机板外，通过接口连接，CPU通过I/O指令访问，用来存储<font color="red">当前不参与运行</font>的数据，<font color="red">容量大但速度慢</font>，例：**硬盘, U盘, 光盘, 移动硬盘**。

2. 按材料分：可分为<font color="red">半导体存储器</font>、<font color="red">磁表面存储器</font>、<font color="red">光存储器</font>、<font color="red">其他新型存储器</font>。
   -  半导体存储器：基于<font color="red">集成电路，速度快，体积小</font>，根据
      <font color="red">所用元件</font>又可分为<font color="red">双极型</font>和<font color="red">MOS型</font>，根据
      是否需要刷新又可分为<font color="red">动态型</font>和<font color="red">静态型</font>，例：**DRAM, SRAM, Flash, ROM**。
   - 磁存储器：利用磁化原理，使用磁介质做成，如磁芯、磁盘、磁泡、磁带等，<font color="red">非易失，容量大，速度慢</font>，例：**硬盘(HDD/SSD), 磁带**。
   - 光存储器：利用<font color="red">激光读写，便携，成本低，速度慢</font>，使用电学和机械部件构成，例：**DVD、CD、Blu-ray Disc**。

3. 按工作方式：可分为<font color='red'>随机存取(读/写)-RAM</font>和<font color='red'>只读</font>存储器，例：**DRAM(主存), SRAM(Cache)**
   - 随机存取(读/写)-RAM存储器：能读取也能写入数据的存储器，
     - 特点：<font color='red'>可读可写，随机访问，易失性</font>。
   - 只读存储器(ROM)：<font color='red'>正常工作</font>过程中只能读取的存储器。
     - 特点：<font color='red'>正常只读，非易失性</font>。
     - 细分(按写入/擦除方式)：
       - MASK ROM（掩模ROM）：内容在芯片<font color='red'>生产时确定，完全不可更改</font>,一般用于存放<font color='red'>程序的BIOS</font>和用于<font color='red'>微程序控制</font>。
       - PROM（可编程ROM）：允许用户用<font color='red'>专用一次性写入，之后不可更改</font>。
       - EPROM（可擦除PROM）：内容既<font color='red'>可以读出也能写入</font>，写入后还能进行修改，可用<font color='red'>紫外线照射整片擦除</font>。
       - EEPROM（电可擦除PROM）：<font color='red'>与PROM相似</font>，可用<font color='red'>电信号进行擦除和编程</font>，支持<font color='red'>字节级擦写</font>。
       - Flash Memory（闪存）：<font color='red'>EEPROM的重要变种</font>，以块为单位进行擦除和编程，<font color='red'>容量大、成本低、擦除速度远快于EPROM</font>。是U盘、SSD、SD卡的存储核心。

## 1.3 高速缓存(Cache)

- 高速缓存（Cache）是位于 <font color='red'>CPU</font> 和 <font color='red'>主内存（DRAM）</font> 之间的一个<font color='red'>小型、高速的存储器</font>。它的作用是存放CPU<font color='red'>最近最可能</font>访问的主内存<font color='red'>数据的副本</font>。
- 核心目的：解决 <font color='red'>CPU 与主内存之间巨大的速度差异</font>（称为<font color='red'>“存储墙”</font>）。CPU的速度比主存快几个数量级，如果没有Cache，CPU将花费大量时间等待数据从慢速的主存传来，造成性能浪费。
- Cache 的<font color='red'>存在</font>对<font color='red'>程序员是透明的</font>，其地址变换和数据块的替换算法均由<font color='red'>硬件实现</font>。
- Cache 通常被集成在 CPU 内以提高访问速度，主要特点是<font color='red'>容量小、速度快、成本高</font>。

### 1.3.1 Cache 的组成

一个典型的 Cache 主要由<font color='red'>存储体（Cache Storage Array）</font>、<font color='red'>控制逻辑（Control Logic）</font>、标签存储器（Tag RAM）组成

1. 存储体:
   - 这是 Cache 的<font color='red'>主体</font>，由高速的 <font color='red'>SRAM（静态随机存储器）</font> 构成，用于实际存储从主存复制过来的<font color='red'>部分</font>数据信息。
   - 它被划分为许多个缓存行（Cache Line） 或缓存块（Cache Block）。缓存行是 Cache 与主存之间数据传输的最小单位（通常为 32 或 64 字节），而不是单个字节或字。

2. 控制逻辑（Control Logic）：
   - 判断 CPU 要访问的信息是否在 Cache 存储器中，若在即为命中，不在则没有命中，这是 Cache 的“大脑”，负责管理所有操作。
   - 功能包括：
     - <font color='red'>地址比较</font>：将 CPU 送来的地址与 Tag RAM 中的标签进行比较，判断命中与否。
     - <font color='red'>命中</font>/缺失判断：根据比较结果产生命中或缺失信号。
     - <font color='red'>替换策略</font>：当发生 Cache 缺失且 Cache 已满时，决定替换掉哪一行旧数据（如 LRU、FIFO、随机等算法）。
     - <font color='red'>写策略</font>：控制写入操作（写直达或写回）。
     - <font color='red'>一致性维护</font>：在多核处理器中，确保多个 Cache 之间的数据一致性（如 MESI 协议）。

3. 标签存储器（Tag RAM）：
   - 这是一个特殊的存储区，用于存放每个缓存行对应的<font color='red'>主内存地址的高位部分</font>，称为 <font color='red'>标签（Tag）</font>。
   - 作用：当 CPU 送来一个内存地址时，Cache 控制器会将该地址的高位与 Tag RAM 中存储的标签进行比较，以判断所请求的数据是否在 Cache 中（即是否命中）。

### 1.3.2 Cache 的三种地址映像

由于计算机都是按主存地址访问的，而应从 Cache 中读取信息，因此就需要地址映像，即
把<font color='red'>主存中的地址映射成 Cache 存储器中的地址</font>,地址映像有三种<font color='red'>直接相连映像、全相连映像、组相连映像</font>。

#### 1.3.2.1 直接相连映像

- **图示**

```mermaid
flowchart TD
    subgraph MainMemory[主内存]
        direction LR
        M0[块 0]
        M1[块 1]
        M2[块 2]
        M3[块 3]
        M4[块 4]
        M5[块 5]
        M6[块 6]
        M7[块 7]
        M8[块 8]
    end

    subgraph Cache[Cache - 直接相联（4行）]
        C0[行 0]
        C1[行 1]
        C2[行 2]
        C3[行 3]
    end

    M0 --> C0
    M4 --> C0
    M8 --> C0
    
    M1 --> C1
    M5 --> C1
    
    M2 --> C2
    M6 --> C2
    
    M3 --> C3
    M7 --> C3

    style M0 fill:#f9f
    style M4 fill:#f9f
    style M8 fill:#f9f
    style C0 fill:#f9f

    style M1 fill:#9cf
    style M5 fill:#9cf
    style C1 fill:#9cf

    style M2 fill:#6f9
    style M6 fill:#6f9
    style C2 fill:#6f9

    style M3 fill:#fc6
    style M7 fill:#fc6
    style C3 fill:#fc6
```
- **工作流程与查找过程**：

```mermaid
flowchart LR
A[CPU发出内存地址] --> B["划分地址<br>Tag:Index:Offset"]
B --> C["使用Index位<br>直接定位到Cache唯一行"]
C --> D{"比较该行的Tag<br>是否匹配?"}
D -- 匹配 --> E[Cache命中]
D -- 不匹配 --> F[Cache缺失]
E --> G["使用Offset<br>从数据块中取出字节"]
F --> H[从主存调块<br>替换该Cache行]
```

- **特点**：
  - 主存中的每一个块只能被放入 Cache 中<font color='red'>唯一的一个特定行</font>，位置是固定的。
  - 映射规则：`Cache 行号 = 主存块号 % Cache 总行数`。
  - 优点：<font color='red'>硬件简单，查找速度快，地址变换简单</font>（只需比较1个Tag）。
  - 缺点：<font color='red'>灵活性差，冲突率高</font>，即使Cache其他行空着，映射到同一行的块也会互相淘汰（例如上图中的块0、4、8竞争行0），造成“抖动”。

#### 1.3.2.2 全相连映像

- **图示**

```mermaid
flowchart TD
    subgraph MainMemory[主内存]
        direction LR
        M0[块 0]
        M1[块 1]
        M2[块 2]
        M3[块 3]
        M4[块 4]
    end

    subgraph Cache[Cache - 全相联（4行）]
        C0[行 0]
        C1[行 1]
        C2[行 2]
        C3[行 3]
    end

    M0 --> C0
    M0 --> C1
    M0 --> C2
    M0 --> C3

    M1 --> C0
    M1 --> C1
    M1 --> C2
    M1 --> C3

    M2 --> C0
    M2 --> C1
    M2 --> C2
    M2 --> C3

    M3 --> C0
    M3 --> C1
    M3 --> C2
    M3 --> C3

    M4 --> C0
    M4 --> C1
    M4 --> C2
    M4 --> C3
```

- **工作流程与查找过程**：

```mermaid
flowchart LR
A[CPU发出内存地址] --> B["划分地址<br>Tag:Offset"]
B --> C["将Tag与Cache中<br>所有行的Tag并行比较"]
C --> D{"是否有任一Tag匹配?"}
D -- 是 --> E[Cache命中]
D -- 否 --> F[Cache缺失]
E --> G["使用Offset<br>从命中行的数据块中取出字节"]
F --> H[从主存调块<br>替换掉Cache中某一行]
```

- **特点**：
  - 主内存中的<font color='red'>任何一块</font>可以被放入 <font color='red'>Cache 中的任意一个空行</font>。
  - 地址变换时，将主存地址高位表示的<font color='red'>主存块号与 Cache 中的块号进行比较</font>，若相同则为命中。
  - 优点：<font color='red'>冲突率最低，空间利用率最高， Cache 的位置不受限制，非常灵活</font>。
  - 缺点：无法直接从主存的块号中直接获取 Cache 的块号，<font color='red'>变换比较复杂，速度较慢，硬件极其复杂、成本高,功耗大</font>，**仅用于小容量Cache（如TLB）**

#### 1.3.2.3 组相连映像

- **图示**

```mermaid
flowchart TD
    subgraph MainMemory[主内存]
        direction LR
        M0[块 0]
        M1[块 1]
        M2[块 2]
        M3[块 3]
        M4[块 4]
        M5[块 5]
        M6[块 6]
    end

    subgraph Cache[Cache - 2路组相联（2组×2路=4行）]
        subgraph Set0[组 0]
            C00[路 0]
            C01[路 1]
        end
        
        subgraph Set1[组 1]
            C10[路 0]
            C11[路 1]
        end
    end

    M0 --> Set0
    M2 --> Set0
    M4 --> Set0
    M6 --> Set0

    M1 --> Set1
    M3 --> Set1
    M5 --> Set1

    style M0 fill:#f9f
    style M2 fill:#6f9
    style M4 fill:#9cf
    style M6 fill:#fc6
    style Set0 fill:#fff

    style M1 fill:#f9f
    style M3 fill:#6f9
    style M5 fill:#9cf
    style Set1 fill:#fff
```
- **工作流程与查找过程**：

```mermaid
flowchart LR
A[CPU发出内存地址] --> B["划分地址<br>Tag:Index:Offset"]
B --> C["使用Index位<br>定位到对应的组"]
C --> D["将Tag与该组内<br>所有路的Tag并行比较"]
D --> E{"组内是否有任一Tag匹配?"}
E -- 是 --> F[Cache命中]
E -- 否 --> G[Cache缺失]
F --> H["使用Offset<br>从命中路的数据块中取出字节"]
G --> I[从主存调块<br>替换掉该组中的某一路]
```
- **特点**：
  - <font color='red'>直接相联</font>和<font color='red'>全相联</font>的折中方案，也是<font color='red'>现代CPU</font>最常用的方式。
  - 具体方法是将 Cache <font color='red'>**先分成组在分块**,组间采用直接映像，组内采用全相连映像</font>方式。
  - 优点：<font color='red'>有效减少了冲突率</font>，硬件复杂度又可接受，<font color='red'>在成本和性能间取得最佳平衡</font>。



#### 1.3.2.4 小结

| 特性        | **直接相联**                          | **全相联**                           | **组相联**                                  |
|:----------|:----------------------------------|:----------------------------------|:-----------------------------------------|
| **映射规则**  | 1块 → 1行                           | 1块 → 任意行                          | 1块 → 1组 → 组内任意行                          |
| **灵活度**   | <font color='red'>最低</font>       | <font color='red'>最高</font>       | 居中                                       |
| **冲突率**   | <font color='red'>最高</font>       | <font color='red'>最低</font>       | 较低                                       |
| **硬件复杂度** | <font color='red'>最低</font>（比1次）  | <font color='red'>最高</font>（比所有行） | 适中（比组内行）                                 |
| **查找速度**  | <font color='red'>最快</font>       | <font color='red'>最慢</font>       | 快                                        |
| **应用**    | <font color='red'>对速度要求极端处</font> | 小容量TLB等                           | <font color='red'>通用CPU Cache（主流）</font> |

### 1.3.3 Cache 的性能分析

设 <font color='red'>$H$</font> 为 Cache 的命中率， <font color='red'>$t_c$</font> 为 Cache 的存取时间， <font color='red'>$t_m$</font> 为主存的访问时间，则 Cache 的等效访问时间(平均访问时间 (AMAT)) <font color='red'>$t_a$</font> 为

:::center  
$t_a = Ht_c+(1-H)t_m$  
::: 

使用 Cache 比不使用 Cache 的 CPU 访问时间的速度提升倍数(加速比) <font color='red'>$R$</font>  为

:::center  
$R = \frac{t_m}{t_a}$  
::: 




## 1.4 主存的扩展

### 1.4.1 核心概念

- **主存扩展**：当单个存储芯片的<font color='red'>容量</font>或<font color='red'>数据位宽</font>不能满足系统要求时，如何用多个芯片组合成一个符合要求的内存模块。
- **内存编址**：CPU如何通过**地址总线**发出的地址信号来唯一地访问内存中的每个存储单元。

这两者紧密相关：扩展方式决定了<font color='red'>物理布局</font>，而编址方式决定了<font color='red'>CPU如何访问这个布局</font>。

---

### 1.4.2 存储芯片的基本参数

在讨论扩展前，必须先了解存储芯片的表示方法：
- <font color='red'>芯片容量 = 单元数 × 数据位宽</font>
- 常用表示法：**`M × N`**
  - `M`：芯片的<font color='red'>存储单元个数</font>（即地址线的寻址范围）。
  - `N`：每个存储单元的<font color='red'>位数</font>-（即数据线的位数）。

**举例**：
- **`8K × 8bit`** 芯片：有 8192 个单元，每个单元存储 8 位（1字节）数据。地址线需要 `log₂(8192) = 13` 根，数据线有 8 根。
- **`1K × 4bit`** 芯片：有 1024 个单元，每个单元存储 4 位数据。地址线需要 `log₂(1024) = 10` 根，数据线有 4 根。

---

### 1.4.3 主存扩展的三种方式

设有一片 `1k × 4位` 的存储芯片，如下图所示  

![存储系统扩展前.png](/img/ruankao/pages/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E6%89%A9%E5%B1%95%E5%89%8D.png)



#### 1.4.3.1 位扩展（增加数据位宽）

- **目的**：增加存储字长（数据位宽），使其与 CPU 的数据总线宽度一致。
- **方法**：将多个芯片的<font color='red'>地址线、片选线、读写控制线</font>全部并联起来，而它们的<font color='red'>数据线</font>分别连接到数据总线的不同位上。
- **特点**：扩展后，<font color='red'>单元数不变，数据位宽增加</font>。所有芯片<font color='red'>同时工作</font>，共同组成一个<font color='red'>完整的字</font>。

**【示例】**

![存储系统位扩展.png](/img/ruankao/pages/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E4%BD%8D%E6%89%A9%E5%B1%95.png)

#### 1.4.3.2 字扩展（增加容量）

*   **目的**：增加存储单元的<font color='red'>个数</font>（容量）。
*   **方法**：将多个芯片的<font color='red'>地址线、数据线、读写控制线</font>全部并联起来。由<font color='red'>片选信号（CS）</font> 或<font color='red'><font color='red'>地址译码器</font></font>的输出信号来区分各个芯片的地址范围。
*   **特点**：扩展后，数据<font color='red'>位宽不变，单元数增加</font>。任何时候<font color='red'>只有一个芯片</font>被选中工作。

**【示例】**

![存储系统字扩展.png](/img/ruankao/pages/%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F%E5%AD%97%E6%89%A9%E5%B1%95.png)


#### 1.4.3.3 字位同时扩展（既增容量又增位宽）

*   **目的**：<font color='red'>同时增加存储单元的个数和数据的位宽</font>。这是最实际、最常见的情况。
*   **方法**：先进行<font color='red'>位扩展</font>，组成多个满足数据位宽要求的"芯片组"；再对这些"芯片组"进行<font color='red'>字扩展</font>。
*   **特点**：扩展后，<font color='red'>单元数和数据位宽都增加</font>。

### 1.4.4 小结

| 扩展方式       | 目的     | 连接特点            | 结果         |
|:-----------|:-------|:----------------|:-----------|
| **位扩展**    | 增加数据位宽 | 地址线、片选线并联；数据线分开 | 单元数不变，字长增加 |
| **字扩展**    | 增加容量   | 地址线、数据线并联；片选线分开 | 字长不变，单元数增加 |
| **字位同时扩展** | 两者都增加  | 先位扩，再字扩         | 单元数和字长都增加  |




### 1.4.5 内存地址的计算

#### 1.4.5.1 例题引入

已知内存地址从 `AC000H` 到 `C7FFFH` ，如果该内存按字（16bit）编址，
由28片存储器芯片构成，已知构成次内存的芯片每片有16K个存储单元。  
问：1、当前内存一共有多少K的地址单元？  
&emsp;&emsp;2、该芯片每个存储单元存储多少位？  

第一问：
1. 计算总地址单元数：**总单元数 = 结束地址 - 起始地址 <font class='blob-600'  color='red'>+ 1</font>**，`C7FFFH - AC000H = 1C000H`
2. 转换成二进制：`0001 1100 0000 0000 0000` 二进制的单位为 `Byte`
3. 直接从二进制转换成 `K` 的单位， `1K = 1024B` 所以需要去除二进制后10位变成 `0001 1100 00`
4. 将二进制转换成 `十` 进制： $1110000 = 2^6+2^5+2^4 = 112$

**答案：当前内存一共 `112K` 个地址单元**  

第二问：  
1. 已知变量
  - **逻辑侧（CPU视角）**
    - 按字编址，**字长 $W$ = 16 bit**
    - 逻辑地址单元数 **$L$ = 112K Word**
    - $逻辑总容量 = L × W = 112K × 16 bit$
  - **物理侧（芯片视角）**：
    - 芯片数量 **$C_n$ = 28**片
    - 每片芯片的存储单元数 **$C_s$ = 16K**
    - 设：每个芯片存储单元存储的位数为 $N bit$
    - $物理总容量 = C_n × C_s × N = 28 × 16K × N bit$
    
2. 建立等式：<font class='color-red blob-600'>逻辑总容量必须等于物理总容量</font>  
   - 则有：<font class='color-red blob-600'>逻辑地址单元数 × 字长 = 芯片数量 × 每片芯片单元数 × 每个单元位数</font>
   - 带入设计变量： $L × W = C_n × C_s × N$
   - 带入已知量： `112K × 16bit = 28 × 16K × Nbit`
   - 约去单位 `K` 、 `bit` 和已知量 `16` 得 `112 = 28 × N`
   - 解得 $n = \frac{112}{28} = 4$

**答案：该芯片每个存储单元存储 `4` 位**

#### 1.4.5.2 验证与分析

- **物理总容量**：28片 × 16K单元/片 × 4bit/单元 = **28 × 16K × 4 bit**。
- **逻辑总容量**：112K字 × 16bit/字 = **112K × 16 bit**。
- **两者相等**：`28 × 16K × 4 = 112K × 16` → `28×4=112` 且 `16K=16K`，等式成立。

**技术含义**：
这意味着内存系统由 **28 片 16K×4bit 的芯片**构成。为了形成 **16bit** 的字长，需要进行**位扩展**。
- **位扩展分组**：字长16bit / 每片4bit = **4片/组**。
- **组数**：总芯片28片 / 每组4片 = **7组**。
- **字扩展**：每组芯片提供16K个存储单元（地址），共7组，正好构成 **7 × 16K = 112K** 的地址空间。

#### 1.4.5.3 最终答案与等式总结

1.  **地址单元数**：**112 K**
2.  **芯片每个存储单元位数**：**4 位**

**涉及到的等式**：
1.  `总地址单元数 = 结束地址 - 起始地址 + 1` -> `C7FFFH - AC000H + 1 = 1C000H = 114688 = 112K`
2.  核心等式：<font class='color-red blob-600'>逻辑地址数 × 字长 = 总芯片数 × 每片单元数 × 每单元位数</font>
3.  数值等式：<font class='color-red blob-600'>112K × 16 = 28 × 16K × n</font>
4.  解：<font class='color-red blob-600'>n = (112K × 16) / (28 × 16K) = 112 / 28 = 4</font>




